// This file is auto-generated by @hey-api/openapi-ts

export const $Body_upload_file_conversations_upload_file_post = {
  properties: {
    conversation_id: {
      type: 'string',
      title: 'Conversation Id',
    },
    file: {
      type: 'string',
      format: 'binary',
      title: 'File',
    },
  },
  type: 'object',
  required: ['file'],
  title: 'Body_upload_file_conversations_upload_file_post',
} as const;

export const $Body_upload_file_with_conversation_conversations__conversation_id__upload_file_post =
  {
    properties: {
      file: {
        type: 'string',
        format: 'binary',
        title: 'File',
      },
    },
    type: 'object',
    required: ['file'],
    title: 'Body_upload_file_with_conversation_conversations__conversation_id__upload_file_post',
  } as const;

export const $Category = {
  type: 'string',
  enum: ['File loader', 'Data loader', 'Function'],
  title: 'Category',
} as const;

export const $ChatMessage = {
  properties: {
    role: {
      allOf: [
        {
          $ref: '#/components/schemas/ChatRole',
        },
      ],
      title: 'One of CHATBOT|USER to identify who the message is coming from.',
    },
    message: {
      type: 'string',
      title: 'Contents of the chat message.',
    },
  },
  type: 'object',
  required: ['role', 'message'],
  title: 'ChatMessage',
  description:
    "A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's message.",
} as const;

export const $ChatResponseEvent = {
  properties: {
    event: {
      allOf: [
        {
          $ref: '#/components/schemas/StreamEvent',
        },
      ],
      title: 'type of stream event',
    },
    data: {
      anyOf: [
        {
          $ref: '#/components/schemas/StreamStart',
        },
        {
          $ref: '#/components/schemas/StreamTextGeneration',
        },
        {
          $ref: '#/components/schemas/StreamCitationGeneration',
        },
        {
          $ref: '#/components/schemas/StreamQueryGeneration',
        },
        {
          $ref: '#/components/schemas/StreamSearchResults',
        },
        {
          $ref: '#/components/schemas/StreamEnd',
        },
        {
          $ref: '#/components/schemas/StreamToolInput',
        },
        {
          $ref: '#/components/schemas/StreamToolResult',
        },
        {
          $ref: '#/components/schemas/StreamSearchQueriesGeneration',
        },
        {
          $ref: '#/components/schemas/StreamToolCallsGeneration',
        },
        {
          $ref: '#/components/schemas/NonStreamedChatResponse',
        },
      ],
      title: 'Data returned from chat response of a given event type',
    },
  },
  type: 'object',
  required: ['event', 'data'],
  title: 'ChatResponseEvent',
} as const;

export const $ChatRole = {
  type: 'string',
  enum: ['CHATBOT', 'USER'],
  title: 'ChatRole',
  description: 'One of CHATBOT|USER to identify who the message is coming from.',
} as const;

export const $Citation = {
  properties: {
    text: {
      type: 'string',
      title: 'Text',
    },
    start: {
      type: 'integer',
      title: 'Start',
    },
    end: {
      type: 'integer',
      title: 'End',
    },
    document_ids: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Document Ids',
    },
  },
  type: 'object',
  required: ['text', 'start', 'end', 'document_ids'],
  title: 'Citation',
} as const;

export const $CohereChatPromptTruncation = {
  type: 'string',
  enum: ['OFF', 'AUTO_PRESERVE_ORDER'],
  title: 'CohereChatPromptTruncation',
  description: 'Dictates how the prompt will be constructed. Defaults to "AUTO_PRESERVE_ORDER".',
} as const;

export const $CohereChatRequest = {
  properties: {
    message: {
      type: 'string',
      title: 'The message to send to the chatbot.',
    },
    chat_history: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/ChatMessage',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title:
        'A list of entries used to construct the conversation. If provided, these messages will be used to build the prompt and the conversation_id will be ignored so no data will be stored to maintain state.',
    },
    conversation_id: {
      type: 'string',
      title:
        'To store a conversation then create a conversation id and use it for every related request',
    },
    tools: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/Tool',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: `
            List of custom or managed tools to use for the response.
            If passing in managed tools, you only need to provide the name of the tool.
            If passing in custom tools, you need to provide the name, description, and optionally parameter defintions of the tool.
            Passing a mix of custom and managed tools is not supported. 

            Managed Tools Examples:
            tools=[
                {
                    "name": "Wiki Retriever - LangChain",
                },
                {
                    "name": "Calculator",
                }
            ]

            Custom Tools Examples:
            tools=[
                {
                    "name": "movie_title_generator",
                    "description": "tool to generate a cool movie title",
                    "parameter_definitions": {
                        "synopsis": {
                            "description": "short synopsis of the movie",
                            "type": "str",
                            "required": true
                        }
                    }
                },
                {
                    "name": "random_number_generator",
                    "description": "tool to generate a random number between min and max",
                    "parameter_definitions": {
                        "min": {
                            "description": "minimum number",
                            "type": "int",
                            "required": true
                        },
                        "max": {
                            "description": "maximum number",
                            "type": "int",
                            "required": true
                        }
                    }  
                },
                {
                    "name": "joke_generator",
                    "description": "tool to generate a random joke",
                }
            ]
        `,
    },
    documents: {
      items: {
        type: 'object',
      },
      type: 'array',
      title: `Documents to use to generate grounded response with citations. Example:
            documents=[
                {
                    "id": "national_geographic_everest",
                    "title": "Height of Mount Everest",
                    "text": "The height of Mount Everest is 29,035 feet",
                    "url": "https://education.nationalgeographic.org/resource/mount-everest/",
                },
                {
                    "id": "national_geographic_mariana",
                    "title": "Depth of the Mariana Trench",
                    "text": "The depth of the Mariana Trench is 36,070 feet",
                    "url": "https://www.nationalgeographic.org/activity/mariana-trench-deepest-place-earth",
                },
            ]
        `,
    },
    model: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'The model to use for generating the response.',
      default: 'command-r',
    },
    temperature: {
      anyOf: [
        {
          type: 'number',
          minimum: 0,
        },
        {
          type: 'null',
        },
      ],
      title:
        'A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.',
    },
    k: {
      anyOf: [
        {
          type: 'integer',
          maximum: 500,
          minimum: 0,
        },
        {
          type: 'null',
        },
      ],
      title:
        'Ensures only the top k most likely tokens are considered for generation at each step.',
    },
    p: {
      anyOf: [
        {
          type: 'number',
          maximum: 0.99,
          minimum: 0,
        },
        {
          type: 'null',
        },
      ],
      title:
        'Ensures that only the most likely tokens, with total probability mass of p, are considered for generation at each step. If both k and p are enabled, p acts after k.',
    },
    preamble: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'A string to override the preamble.',
    },
    file_ids: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'List of File IDs for PDFs used in RAG for the response.',
    },
    search_queries_only: {
      anyOf: [
        {
          type: 'boolean',
        },
        {
          type: 'null',
        },
      ],
      title:
        "When set to true a list of search queries are generated. No search will occur nor replies to the user's message.",
      default: false,
    },
    max_tokens: {
      anyOf: [
        {
          type: 'integer',
          minimum: 1,
        },
        {
          type: 'null',
        },
      ],
      title:
        'The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.',
    },
    seed: {
      anyOf: [
        {
          type: 'number',
        },
        {
          type: 'null',
        },
      ],
      title:
        'If specified, the backend will make a best effort to sample tokens deterministically, such that repeated requests with the same seed and parameters should return the same result. However, determinism cannot be totally guaranteed.',
    },
    stop_sequences: {
      anyOf: [
        {
          items: {
            type: 'string',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title:
        'A list of up to 5 strings that the model will use to stop generation. If the model generates a string that matches any of the strings in the list, it will stop generating tokens and return the generated text up to that point not including the stop sequence.',
    },
    presence_penalty: {
      anyOf: [
        {
          type: 'number',
          maximum: 1,
          minimum: 0,
        },
        {
          type: 'null',
        },
      ],
      title:
        'Used to reduce repetitiveness of generated tokens. Similar to frequency_penalty, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.',
    },
    frequency_penalty: {
      anyOf: [
        {
          type: 'number',
          maximum: 1,
          minimum: 0,
        },
        {
          type: 'null',
        },
      ],
      title:
        'Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.',
    },
    prompt_truncation: {
      allOf: [
        {
          $ref: '#/components/schemas/CohereChatPromptTruncation',
        },
      ],
      title: "Dictates how the prompt will be constructed. Defaults to 'AUTO_PRESERVE_ORDER'.",
      default: 'AUTO_PRESERVE_ORDER',
    },
  },
  type: 'object',
  required: ['message'],
  title: 'CohereChatRequest',
  description: `Request shape for Cohere Python SDK Streamed Chat.
See: https://github.com/cohere-ai/cohere-python/blob/main/src/cohere/base_client.py#L1629`,
} as const;

export const $Conversation = {
  properties: {
    user_id: {
      type: 'string',
      title: 'User Id',
    },
    id: {
      type: 'string',
      title: 'Id',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
    },
    updated_at: {
      type: 'string',
      format: 'date-time',
      title: 'Updated At',
    },
    title: {
      type: 'string',
      title: 'Title',
    },
    messages: {
      items: {
        $ref: '#/components/schemas/Message',
      },
      type: 'array',
      title: 'Messages',
    },
    files: {
      items: {
        $ref: '#/components/schemas/File',
      },
      type: 'array',
      title: 'Files',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
    total_file_size: {
      type: 'integer',
      title: 'Total File Size',
      readOnly: true,
    },
  },
  type: 'object',
  required: [
    'user_id',
    'id',
    'created_at',
    'updated_at',
    'title',
    'messages',
    'files',
    'description',
    'total_file_size',
  ],
  title: 'Conversation',
} as const;

export const $ConversationWithoutMessages = {
  properties: {
    user_id: {
      type: 'string',
      title: 'User Id',
    },
    id: {
      type: 'string',
      title: 'Id',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
    },
    updated_at: {
      type: 'string',
      format: 'date-time',
      title: 'Updated At',
    },
    title: {
      type: 'string',
      title: 'Title',
    },
    files: {
      items: {
        $ref: '#/components/schemas/File',
      },
      type: 'array',
      title: 'Files',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
    total_file_size: {
      type: 'integer',
      title: 'Total File Size',
      readOnly: true,
    },
  },
  type: 'object',
  required: [
    'user_id',
    'id',
    'created_at',
    'updated_at',
    'title',
    'files',
    'description',
    'total_file_size',
  ],
  title: 'ConversationWithoutMessages',
} as const;

export const $CreateUser = {
  properties: {
    fullname: {
      type: 'string',
      title: 'Fullname',
    },
    email: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Email',
    },
  },
  type: 'object',
  required: ['fullname'],
  title: 'CreateUser',
} as const;

export const $DeleteConversation = {
  properties: {},
  type: 'object',
  title: 'DeleteConversation',
} as const;

export const $DeleteFile = {
  properties: {},
  type: 'object',
  title: 'DeleteFile',
} as const;

export const $DeleteUser = {
  properties: {},
  type: 'object',
  title: 'DeleteUser',
} as const;

export const $Deployment = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
    },
    models: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Models',
    },
    env_vars: {
      items: {
        type: 'string',
      },
      type: 'array',
      title: 'Env Vars',
    },
  },
  type: 'object',
  required: ['name', 'models', 'env_vars'],
  title: 'Deployment',
} as const;

export const $Document = {
  properties: {
    text: {
      type: 'string',
      title: 'Text',
    },
    document_id: {
      type: 'string',
      title: 'Document Id',
    },
    title: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Title',
    },
    url: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Url',
    },
  },
  type: 'object',
  required: ['text', 'document_id', 'title', 'url'],
  title: 'Document',
} as const;

export const $File = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
    },
    updated_at: {
      type: 'string',
      format: 'date-time',
      title: 'Updated At',
    },
    user_id: {
      type: 'string',
      title: 'User Id',
    },
    conversation_id: {
      type: 'string',
      title: 'Conversation Id',
    },
    file_name: {
      type: 'string',
      title: 'File Name',
    },
    file_path: {
      type: 'string',
      title: 'File Path',
    },
    file_size: {
      type: 'integer',
      minimum: 0,
      title: 'File Size',
      default: 0,
    },
  },
  type: 'object',
  required: [
    'id',
    'created_at',
    'updated_at',
    'user_id',
    'conversation_id',
    'file_name',
    'file_path',
  ],
  title: 'File',
} as const;

export const $HTTPValidationError = {
  properties: {
    detail: {
      items: {
        $ref: '#/components/schemas/ValidationError',
      },
      type: 'array',
      title: 'Detail',
    },
  },
  type: 'object',
  title: 'HTTPValidationError',
} as const;

export const $LangchainChatRequest = {
  properties: {
    message: {
      type: 'string',
      title: 'The message to send to the chatbot.',
    },
    chat_history: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/ChatMessage',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title:
        'A list of entries used to construct the conversation. If provided, these messages will be used to build the prompt and the conversation_id will be ignored so no data will be stored to maintain state.',
    },
    conversation_id: {
      type: 'string',
      title:
        'To store a conversation then create a conversation id and use it for every related request',
    },
    tools: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/Tool',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: `
            List of custom or managed tools to use for the response.
            If passing in managed tools, you only need to provide the name of the tool.
            If passing in custom tools, you need to provide the name, description, and optionally parameter defintions of the tool.
            Passing a mix of custom and managed tools is not supported. 

            Managed Tools Examples:
            tools=[
                {
                    "name": "Wiki Retriever - LangChain",
                },
                {
                    "name": "Calculator",
                }
            ]

            Custom Tools Examples:
            tools=[
                {
                    "name": "movie_title_generator",
                    "description": "tool to generate a cool movie title",
                    "parameter_definitions": {
                        "synopsis": {
                            "description": "short synopsis of the movie",
                            "type": "str",
                            "required": true
                        }
                    }
                },
                {
                    "name": "random_number_generator",
                    "description": "tool to generate a random number between min and max",
                    "parameter_definitions": {
                        "min": {
                            "description": "minimum number",
                            "type": "int",
                            "required": true
                        },
                        "max": {
                            "description": "maximum number",
                            "type": "int",
                            "required": true
                        }
                    }  
                },
                {
                    "name": "joke_generator",
                    "description": "tool to generate a random joke",
                }
            ]
        `,
    },
  },
  type: 'object',
  required: ['message'],
  title: 'LangchainChatRequest',
  description: 'Request shape for Langchain Streamed Chat.',
} as const;

export const $ListFile = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
    },
    updated_at: {
      type: 'string',
      format: 'date-time',
      title: 'Updated At',
    },
    user_id: {
      type: 'string',
      title: 'User Id',
    },
    conversation_id: {
      type: 'string',
      title: 'Conversation Id',
    },
    file_name: {
      type: 'string',
      title: 'File Name',
    },
    file_path: {
      type: 'string',
      title: 'File Path',
    },
    file_size: {
      type: 'integer',
      minimum: 0,
      title: 'File Size',
      default: 0,
    },
  },
  type: 'object',
  required: [
    'id',
    'created_at',
    'updated_at',
    'user_id',
    'conversation_id',
    'file_name',
    'file_path',
  ],
  title: 'ListFile',
} as const;

export const $ManagedTool = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      default: '',
    },
    parameter_definitions: {
      anyOf: [
        {
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Parameter Definitions',
      default: {},
    },
    kwargs: {
      type: 'object',
      title: 'Kwargs',
      default: {},
    },
    is_visible: {
      type: 'boolean',
      title: 'Is Visible',
      default: false,
    },
    is_available: {
      type: 'boolean',
      title: 'Is Available',
      default: false,
    },
    error_message: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Error Message',
      default: '',
    },
    category: {
      allOf: [
        {
          $ref: '#/components/schemas/Category',
        },
      ],
      default: 'Data loader',
    },
  },
  type: 'object',
  required: ['name'],
  title: 'ManagedTool',
} as const;

export const $Message = {
  properties: {
    text: {
      type: 'string',
      title: 'Text',
    },
    id: {
      type: 'string',
      title: 'Id',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
    },
    updated_at: {
      type: 'string',
      format: 'date-time',
      title: 'Updated At',
    },
    generation_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Generation Id',
    },
    position: {
      type: 'integer',
      title: 'Position',
    },
    is_active: {
      type: 'boolean',
      title: 'Is Active',
    },
    documents: {
      items: {
        $ref: '#/components/schemas/Document',
      },
      type: 'array',
      title: 'Documents',
    },
    citations: {
      items: {
        $ref: '#/components/schemas/Citation',
      },
      type: 'array',
      title: 'Citations',
    },
    files: {
      items: {
        $ref: '#/components/schemas/File',
      },
      type: 'array',
      title: 'Files',
    },
    agent: {
      $ref: '#/components/schemas/MessageAgent',
    },
  },
  type: 'object',
  required: [
    'text',
    'id',
    'created_at',
    'updated_at',
    'generation_id',
    'position',
    'is_active',
    'documents',
    'citations',
    'files',
    'agent',
  ],
  title: 'Message',
} as const;

export const $MessageAgent = {
  type: 'string',
  enum: ['USER', 'CHATBOT'],
  title: 'MessageAgent',
} as const;

export const $NonStreamedChatResponse = {
  properties: {
    is_finished: {
      type: 'boolean',
      title: 'Denotes whether or not the chat stream has finished.',
    },
    response_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Unique identifier for the response.',
    },
    generation_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Unique identifier for the generation.',
    },
    chat_history: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/ChatMessage',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title:
        "A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's message.",
    },
    finish_reason: {
      type: 'string',
      title: 'Reason the chat stream ended.',
    },
    text: {
      type: 'string',
      title: 'Contents of the chat message.',
    },
    citations: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/Citation',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Citations for the chat message.',
      default: [],
    },
    documents: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/Document',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Documents used to generate grounded response with citations.',
      default: [],
    },
    search_results: {
      anyOf: [
        {
          items: {
            type: 'object',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'Search results used to generate grounded response with citations.',
      default: [],
    },
    search_queries: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/SearchQuery',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'List of generated search queries.',
      default: [],
    },
    conversation_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title:
        'To store a conversation then create a conversation id and use it for every related request.',
    },
    tool_calls: {
      anyOf: [
        {
          items: {
            $ref: '#/components/schemas/ToolCall',
          },
          type: 'array',
        },
        {
          type: 'null',
        },
      ],
      title: 'List of tool calls generated for custom tools',
      default: [],
    },
  },
  type: 'object',
  required: [
    'is_finished',
    'response_id',
    'generation_id',
    'chat_history',
    'finish_reason',
    'text',
    'conversation_id',
  ],
  title: 'NonStreamedChatResponse',
} as const;

export const $SearchQuery = {
  properties: {
    text: {
      type: 'string',
      title: 'Text',
    },
    generation_id: {
      type: 'string',
      title: 'Generation Id',
    },
  },
  type: 'object',
  required: ['text', 'generation_id'],
  title: 'SearchQuery',
} as const;

export const $StreamCitationGeneration = {
  properties: {
    is_finished: {
      type: 'boolean',
      title: 'Denotes whether or not the chat stream has finished.',
    },
    citations: {
      items: {
        $ref: '#/components/schemas/Citation',
      },
      type: 'array',
      title: 'Citations for the chat message.',
      default: [],
    },
  },
  type: 'object',
  required: ['is_finished'],
  title: 'StreamCitationGeneration',
  description: 'Stream citation generation event.',
} as const;

export const $StreamEnd = {
  properties: {
    response_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Response Id',
    },
    generation_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Generation Id',
    },
    conversation_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Conversation Id',
    },
    text: {
      type: 'string',
      title: 'Contents of the chat message.',
    },
    citations: {
      items: {
        $ref: '#/components/schemas/Citation',
      },
      type: 'array',
      title: 'Citations for the chat message.',
      default: [],
    },
    documents: {
      items: {
        $ref: '#/components/schemas/Document',
      },
      type: 'array',
      title: 'Documents used to generate grounded response with citations.',
      default: [],
    },
    search_results: {
      items: {
        type: 'object',
      },
      type: 'array',
      title: 'Search results used to generate grounded response with citations.',
      default: [],
    },
    search_queries: {
      items: {
        $ref: '#/components/schemas/SearchQuery',
      },
      type: 'array',
      title: 'List of generated search queries.',
      default: [],
    },
    tool_calls: {
      items: {
        $ref: '#/components/schemas/ToolCall',
      },
      type: 'array',
      title: 'List of tool calls generated for custom tools',
      default: [],
    },
    finish_reason: {
      type: 'string',
      title: 'Finish Reason',
    },
  },
  type: 'object',
  required: ['text', 'finish_reason'],
  title: 'StreamEnd',
} as const;

export const $StreamEvent = {
  type: 'string',
  enum: [
    'stream-start',
    'search-queries-generation',
    'search-results',
    'tool-input',
    'tool-result',
    'text-generation',
    'citation-generation',
    'stream-end',
    'non-streamed-chat-response',
    'tool-calls-generation',
  ],
  title: 'StreamEvent',
  description: "Stream Events returned by Cohere's chat stream response.",
} as const;

export const $StreamQueryGeneration = {
  properties: {
    is_finished: {
      type: 'boolean',
      title: 'Denotes whether or not the chat stream has finished.',
    },
    query: {
      type: 'string',
      title: 'Search query used to generate grounded response with citations.',
    },
  },
  type: 'object',
  required: ['is_finished', 'query'],
  title: 'StreamQueryGeneration',
  description: 'Stream query generation event.',
} as const;

export const $StreamSearchQueriesGeneration = {
  properties: {
    is_finished: {
      type: 'boolean',
      title: 'Denotes whether or not the chat stream has finished.',
    },
    search_queries: {
      items: {
        $ref: '#/components/schemas/SearchQuery',
      },
      type: 'array',
      title: 'Search query used to generate grounded response with citations.',
      default: [],
    },
  },
  type: 'object',
  required: ['is_finished'],
  title: 'StreamSearchQueriesGeneration',
  description: 'Stream queries generation event.',
} as const;

export const $StreamSearchResults = {
  properties: {
    is_finished: {
      type: 'boolean',
      title: 'Denotes whether or not the chat stream has finished.',
    },
    search_results: {
      items: {
        type: 'object',
      },
      type: 'array',
      title: 'Search results used to generate grounded response with citations.',
      default: [],
    },
    documents: {
      items: {
        $ref: '#/components/schemas/Document',
      },
      type: 'array',
      title: 'Documents used to generate grounded response with citations.',
      default: [],
    },
  },
  type: 'object',
  required: ['is_finished'],
  title: 'StreamSearchResults',
} as const;

export const $StreamStart = {
  properties: {
    is_finished: {
      type: 'boolean',
      title: 'Denotes whether or not the chat stream has finished.',
    },
    generation_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Generation Id',
    },
    conversation_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Conversation Id',
    },
  },
  type: 'object',
  required: ['is_finished'],
  title: 'StreamStart',
  description: 'Stream start event.',
} as const;

export const $StreamTextGeneration = {
  properties: {
    is_finished: {
      type: 'boolean',
      title: 'Denotes whether or not the chat stream has finished.',
    },
    text: {
      type: 'string',
      title: 'Contents of the chat message.',
    },
  },
  type: 'object',
  required: ['is_finished', 'text'],
  title: 'StreamTextGeneration',
  description: 'Stream text generation event.',
} as const;

export const $StreamToolCallsGeneration = {
  properties: {
    is_finished: {
      type: 'boolean',
      title: 'Denotes whether or not the chat stream has finished.',
    },
    tool_calls: {
      items: {
        $ref: '#/components/schemas/ToolCall',
      },
      type: 'array',
      title: 'List of tool calls generated for custom tools',
      default: [],
    },
  },
  type: 'object',
  required: ['is_finished'],
  title: 'StreamToolCallsGeneration',
  description: 'Stream tool calls generation event.',
} as const;

export const $StreamToolInput = {
  properties: {
    is_finished: {
      type: 'boolean',
      title: 'Denotes whether or not the chat stream has finished.',
    },
    input_type: {
      $ref: '#/components/schemas/ToolInputType',
    },
    tool_name: {
      type: 'string',
      title: 'Tool Name',
    },
    input: {
      type: 'string',
      title: 'Input',
    },
    text: {
      type: 'string',
      title: 'Text',
    },
  },
  type: 'object',
  required: ['is_finished', 'input_type', 'tool_name', 'input', 'text'],
  title: 'StreamToolInput',
} as const;

export const $StreamToolResult = {
  properties: {
    is_finished: {
      type: 'boolean',
      title: 'Denotes whether or not the chat stream has finished.',
    },
    result: {
      title: 'Result',
    },
    tool_name: {
      type: 'string',
      title: 'Tool Name',
    },
    documents: {
      items: {
        $ref: '#/components/schemas/Document',
      },
      type: 'array',
      title: 'Documents used to generate grounded response with citations.',
      default: [],
    },
  },
  type: 'object',
  required: ['is_finished', 'result', 'tool_name'],
  title: 'StreamToolResult',
} as const;

export const $Tool = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
      default: '',
    },
    parameter_definitions: {
      anyOf: [
        {
          type: 'object',
        },
        {
          type: 'null',
        },
      ],
      title: 'Parameter Definitions',
      default: {},
    },
  },
  type: 'object',
  required: ['name'],
  title: 'Tool',
} as const;

export const $ToolCall = {
  properties: {
    name: {
      type: 'string',
      title: 'Name',
    },
    parameters: {
      type: 'object',
      title: 'Parameters',
      default: {},
    },
  },
  type: 'object',
  required: ['name'],
  title: 'ToolCall',
} as const;

export const $ToolInputType = {
  type: 'string',
  enum: ['QUERY', 'CODE'],
  title: 'ToolInputType',
  description: 'Type of input passed to the tool',
} as const;

export const $UpdateConversation = {
  properties: {
    title: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Title',
    },
    description: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Description',
    },
  },
  type: 'object',
  title: 'UpdateConversation',
} as const;

export const $UpdateDeploymentEnv = {
  properties: {
    env_vars: {
      additionalProperties: {
        type: 'string',
      },
      type: 'object',
      title: 'Env Vars',
    },
  },
  type: 'object',
  required: ['env_vars'],
  title: 'UpdateDeploymentEnv',
} as const;

export const $UpdateFile = {
  properties: {
    file_name: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'File Name',
    },
    message_id: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Message Id',
    },
  },
  type: 'object',
  title: 'UpdateFile',
} as const;

export const $UpdateUser = {
  properties: {
    fullname: {
      type: 'string',
      title: 'Fullname',
    },
    email: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Email',
    },
  },
  type: 'object',
  required: ['fullname'],
  title: 'UpdateUser',
} as const;

export const $UploadFile = {
  properties: {
    id: {
      type: 'string',
      title: 'Id',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
    },
    updated_at: {
      type: 'string',
      format: 'date-time',
      title: 'Updated At',
    },
    user_id: {
      type: 'string',
      title: 'User Id',
    },
    conversation_id: {
      type: 'string',
      title: 'Conversation Id',
    },
    file_name: {
      type: 'string',
      title: 'File Name',
    },
    file_path: {
      type: 'string',
      title: 'File Path',
    },
    file_size: {
      type: 'integer',
      minimum: 0,
      title: 'File Size',
      default: 0,
    },
  },
  type: 'object',
  required: [
    'id',
    'created_at',
    'updated_at',
    'user_id',
    'conversation_id',
    'file_name',
    'file_path',
  ],
  title: 'UploadFile',
} as const;

export const $User = {
  properties: {
    fullname: {
      type: 'string',
      title: 'Fullname',
    },
    email: {
      anyOf: [
        {
          type: 'string',
        },
        {
          type: 'null',
        },
      ],
      title: 'Email',
    },
    id: {
      type: 'string',
      title: 'Id',
    },
    created_at: {
      type: 'string',
      format: 'date-time',
      title: 'Created At',
    },
    updated_at: {
      type: 'string',
      format: 'date-time',
      title: 'Updated At',
    },
  },
  type: 'object',
  required: ['fullname', 'id', 'created_at', 'updated_at'],
  title: 'User',
} as const;

export const $ValidationError = {
  properties: {
    loc: {
      items: {
        anyOf: [
          {
            type: 'string',
          },
          {
            type: 'integer',
          },
        ],
      },
      type: 'array',
      title: 'Location',
    },
    msg: {
      type: 'string',
      title: 'Message',
    },
    type: {
      type: 'string',
      title: 'Error Type',
    },
  },
  type: 'object',
  required: ['loc', 'msg', 'type'],
  title: 'ValidationError',
} as const;
